#!/bin/sh

trap _cleanup INT QUIT #trap ctrl-c

updates="http://minos.io/s"
liner="$ sh <(wget -qO- minos.io/s)"

if [ -z "${1}" ]; then
    mode="core"; cx="\b>"
else
    case "${1}" in
        d|desktop) mode="desktop"; dx="\b>";;
           b|boot) mode="boot";    bx="\b>";;
                *) mode="core";    cx="\b>";;
    esac
fi

################################################################################
# General functions ############################################################
################################################################################

_animate_while() {
    [ -z "${1}" ] && { printf "%5s\n" ""; return 1; }

    if ! printf "%s" "$(pidof "${1}")" | grep "[0-9].*" >/dev/null; then
        printf "%5s\n" ""
        return 1;
    fi

    _awhile__animation_state="1"

    if [ ! "$(ps -p "$(pidof "${1}")" -o comm= 2>/dev/null)" ]; then
        printf "%5s\n" ""
        return 1
    fi

    printf "%5s" ""

    while [ "$(ps -p "$(pidof "${1}")" -o comm= 2>/dev/null)" ]; do
        printf "%b" "\b\b\b\b\b"
        case "${_awhile__animation_state}" in
            1) printf "%s" '\o@o\'
               _awhile__animation_state="2" ;;
            2) printf "%s" '|o@o|'
               _awhile__animation_state="3" ;;
            3) printf "%s" '/o@o/'
               _awhile__animation_state="4" ;;
            4) printf "%s" '|o@o|'
               _awhile__animation_state="1" ;;
        esac
        sleep 1
    done
    printf "%b" "\b\b\b\b\b" && printf "%5s\n" ""
}

_basename() {
    [ -z "${1}" ] && return 1 || _basename_var_name="${1}"
    [ -z "${2}" ] || _basename_var_suffix="${2}"
    case "${_basename_var_name}" in
        /*|*/*) _basename_var_name="$(expr "${_basename_var_name}" : '.*/\([^/]*\)')" ;;
    esac

    if [ -n "${_basename_var_suffix}" ] && [ "${#_basename_var_name}" -gt "${#2}" ]; then
        if [ X"$(printf "%s" "${_basename_var_name}" | cut -c"$((${#_basename_var_name} - ${#_basename_var_suffix} + 1))"-"${#_basename_var_name}")" \
           = X"$(printf "%s" "${_basename_var_suffix}")" ]; then
            _basename_var_name="$(printf "%s" "${_basename_var_name}" | cut -c1-"$((${#_basename_var_name} - ${#_basename_var_suffix}))")"
        fi
    fi

    printf "%s\\n" "${_basename_var_name}"
}

_get_root_passwd() { #get sudo's password, define $sudopwd and $sudocmd
    if [ ! X"${LOGNAME}" = X"root" ]; then
        printf "%s\\n" "Detecting user ${LOGNAME} (non-root) ..."
        printf "%s\\n" "Checking if sudo is available ..."

        if command -v "sudo" >/dev/null 2>&1; then
            sudo -K

            if [ -n "${sudopwd}" ]; then
                # password check
                _getroot_var_test="$(printf "%s\\n" "${sudopwd}" | sudo -S ls 2>&1)"
                _getroot_var_status="${?}"
                _getroot_var_not_allowed="$(printf "%s" "${_getroot_var_test}" | grep -i "sudoers")"

                if [ -n "${_getroot_var_not_allowed}" ]; then
                    printf "%s %s\\n" "You're not allowed to use sudo," \
                           "get in contact with your local administrator"
                    exit
                fi

                if [ X"${_getroot_var_status}" != X"0" ]; then
                    sudopwd=""
                    printf "%s\\n" "Incorrect preseed password"
                    exit
                else
                    sudocmd="sudo -S"
                fi
                printf "%s\\n" "    - all set ..."
                return
            fi

            i=0 ; while [ "${i}" -lt "3" ]; do
                i="$(expr "${i}" + 1)"
                printf "%s" "   - enter sudo password: "
                stty -echo
                read sudopwd
                stty echo

                # password check
                _getroot_var_test="$(printf "%s\\n" "${sudopwd}" | sudo -S ls 2>&1)"
                _getroot_var_status="${?}"
                _getroot_var_not_allowed="$(printf "%s" "${_getroot_var_test}" | \
                                         grep -i "sudoers")"

                if [ -n "${_getroot_var_not_allowed}" ]; then
                    printf "\\n%s %s\\n" "You're not allowed to use sudo," \
                    "get in contact with your local administrator"
                    exit
                fi

                printf "\\n"
                if [ X"${_getroot_var_status}" != X"0" ]; then
                    sudopwd=""
                else
                    sudocmd="sudo -S"
                    break
                fi
            done

            if [ -z "${sudopwd}" ]; then
                printf "%s\\n" "Failed authentication"
                exit
            fi
        else
            printf "%s %s\\n" "You're not root and sudo isn't available." \
            "Please run this script as root!"
            exit
        fi
    fi
}

_printfl() { #print lines
    _printfl_var_max_len="80"
    if [ -n "${1}" ]; then
        _printfl_var_word_len="$(expr "${#1}" + 2)"
        _printfl_var_sub="$(expr "${_printfl_var_max_len}" - "${_printfl_var_word_len}")"
        _printfl_var_half="$(expr "${_printfl_var_sub}" / 2)"
        _printfl_var_other_half="$(expr "${_printfl_var_sub}" - "${_printfl_var_half}")"
        printf "%b" "\033[1m" #white strong
        printf '%*s' "${_printfl_var_half}" '' | tr ' ' -
        printf "%b" "\033[7m" #white background
        printf " %s " "${1}"
        printf "%b" "\033[0m\033[1m" #white strong
        printf '%*s' "${_printfl_var_other_half}" '' | tr ' ' -
        printf "%b" "\033[0m" #back to normal
        printf "\\n"
    else
        printf "%b" "\033[1m" #white strong
        printf '%*s' "${_printfl_var_max_len}" '' | tr ' ' -
        printf "%b" "\033[0m" #back to normal
        printf "\\n"
    fi
}

_printfs() { #print steps
    [ -z "${1}" ] && return 1
    printf "%s\\n" "[+] ${*}"
}

_printfc() { #print commands
    [ -z "${1}" ] && return 1
    printf "%s\\n" "    $ ${*}"
}

_unprintf() { #unprint sentence
    [ -z "${1}" ] && return 1
    _unprintf_var_word_len="$(expr ${#1})"
    _unprintf_var_i="0"
    while [ "${_unprintf_var_i}" -lt "$(expr "${_unprintf_var_word_len}")" ]; do
        _unprintf_var_i="$(expr "${_unprintf_var_i}" + 1)"
        printf "%b" "\b"
    done
}

_distro() { #return distro name in lower case
    _distro_var_DIST_INFO="/etc/lsb-release"
    if [ -r "${_distro_var_DIST_INFO}" ]; then
        . "${_distro_var_DIST_INFO}"
    fi

    if [ -z "${DISTRIB_ID}" ]; then
        _distro_var_DISTRIB_ID="Unknown";
        if [ -r /etc/debian_version ]; then
            _distro_var_DISTRIB_ID="Debian"
        elif [ -r /etc/issue ]; then
            _distro_var_DISTRIB_ID="$(awk '{print $1}' /etc/issue.net)"
            if [ X"${_distro_var_DISTRIB_ID}" = X"Ubuntu" ]; then
                _distro_var_DISTRIB_ID="Ubuntu"
            fi
        fi
        printf "%s\\n" "${_distro_var_DISTRIB_ID}" | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'
    else
        printf "%s\\n" "${DISTRIB_ID}" | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'
    fi
}

_hooks() {
    [ -z "${1}" ] && return 1
    case "${1}" in
        A|B|C)
            for _hooks_var_script in "${HOME}"/.minos/hooks/"${1}"*; do
                break
            done

            if [ -f "${_hooks_var_script}" ]; then
                _printfl "Executing ${1} hooks"
            else
                return 1
            fi

            for _hooks_var_script in "${HOME}"/.minos/hooks/"${1}"*; do
                if [ -f "${_hooks_var_script}" ]; then
                    _printfs "${_hooks_var_script} ..."
                    . "${_hooks_var_script}"
                fi
            done
            ;;
    esac
}

_get_release() {
    if command -v "lsb_release" 1>/dev/null 2>&1; then
        _getrelease_var_release="$(lsb_release -s -c)"
    else
        if [ -f /etc/apt/sources.list ]; then
            _getrelease_var_release="$(awk -F" " '/^deb .*/ {print $3; exit}' /etc/apt/sources.list)"
        fi
    fi

    printf "%s\\n" "${_getrelease_var_release}"
}

_fetch_file() {
    [ -z "${1}" ] && return 1 || _fetchfile_var_url="${1}"
    [ -z "${2}" ] && _fetchfile_var_output="" || _fetchfile_var_output="${2}"
    _fetchfile_var_max_retries="10"

    _fetchfile_var_i="0"
    while [ "${_fetchfile_var_i}" -lt "${_fetchfile_var_max_retries}" ]; do
        _fetchfile_var_i="$(expr "${_fetchfile_var_i}" + 1)"

        if [ -z "${_fetchfile_var_output}" ]; then
            _waitfor wget "${_fetchfile_var_url}"
        else
            _waitfor wget "${_fetchfile_var_url}" -O "${_fetchfile_var_output}"
        fi

        if [ -n "${_fetchfile_var_output}" ] && [ -f "${_fetchfile_var_output}" ]; then
            break
        elif [ -z "${_fetchfile_var_output}"]; then
            if [ -f "./$(_basename "${_fetchfile_var_url}")" ] || [ -f index.html ]; then
                break
            fi
        else
            if [ "${_fetchfile_var_i}" -eq "$(expr "${_fetchfile_var_max_retries}" - 1)" ]; then
                printf "%s" "Impossible to retrive files"
                exit 1
            else
                printf "[-] %s" "${_fetchfile_var_url} seems down, retrying in ${_fetchfile_var_i} minute(s) ..."
                sleep "$(expr "${_fetchfile_var_i}" \* 60)"
                printf "\\n"
            fi
        fi
    done
}

_exists_apt_proxy() { #look for apt proxies, return 0 on sucess, 1 otherwise
    avahi-browse -a  -t | grep apt-cacher-ng >/dev/null && return 0
    return 1
}

_die() { #print a stacktrace with a msg, exits with 1
    if [ -n "${BASH}" ]; then
        _die_var_frame="0"
        while caller "${_die_var_frame}"; do
            _die_var_frame="$(expr "${_die_var_frame}" + 1)"
        done
    fi

    printf "%s\\n" "${*}"
    exit
}

_seconds2human() {
    [ -z "${1}" ] && return 1
    printf "%s\\n" "${1}" | grep -v "[^0-9]" >/dev/null || return 1;

    _s2h__num="${1}"
    _s2h__min="0"
    _s2h__hour="0"
    _s2h__day="0"

    if [ "${_s2h__num}" -gt "59" ]; then
        _s2h__sec="$((${_s2h__num} % 60))"
        _s2h__num="$((${_s2h__num} / 60))"
        if [ "${_s2h__num}" -gt "59" ]; then
            _s2h__min="$((${_s2h__num} % 60))"
            _s2h__num="$((${_s2h__num} / 60))"
            if [ "${_s2h__num}" -gt "23" ]; then
                _s2h__hour="$((${_s2h__num} % 24))"
                _s2h__day="$((${_s2h__num} / 24))"
            else
                _s2h__hour="${_s2h__num}"
            fi
        else
            _s2h__min="${_s2h__num}"
        fi
    else
        _s2h__sec="${_s2h__num}"
    fi

    [ "${_s2h__day}"  -gt 0 ] && printf "%s" "${_s2h__day}d "
    [ "${_s2h__hour}" -gt 0 ] && printf "%s" "${_s2h__day}h "
    [ "${_s2h__min}"  -gt 0 ] && printf "%s" "${_s2h__min}m "
    printf "%s" "${_s2h__sec}s"
    printf "\\n"
}

_apt_update() {
    [ -z "${1}" ] && _aupdate__cache_seconds="3600" || _aupdate__cache_seconds="${1}"
    _aupdate__cache_file="/var/cache/apt/pkgcache.bin"
    if [ -f "${_aupdate__cache_file}" ]; then
        _aupdate__last="$(stat -c %Y "${_aupdate__cache_file}")"
        _aupdate__now="$(date +'%s')"
        _aupdate__diff="$(($_aupdate__now - $_aupdate__last))"
        if [ "${_aupdate__diff}" -lt "${_aupdate__cache_seconds}" ]; then
            _printfs "apt-get update was recently used ($(_seconds2human "${_aupdate__diff}") ago), skipping ..."
        else
            _waitforsudo apt-get update
        fi
    else
        _waitforsudo apt-get update
    fi
}

_cmd() { #print and execute a command, exit on fail
    [ -z "${1}" ] && return 1
    printf "%s \\n" "    $ ${*}"
    _cmd_var_output="$(eval ${@} 2>&1)"
    _cmd_var_status="${?}"
    if [ X"${_cmd_var_status}" != X"0" ]; then
        printf "> %s:%s" "${*}" "${_cmd_var_output}"
        printf "\\n"
        exit "${_cmd_var_status}"
    else
        return "${_cmd_var_status}"
    fi
}

_cmd_verbose() {
    [ -z "${1}" ] && return 1
    printf "%s \\n" "    $ ${*}"
    $@
}

_cmdsudo() { #print && execute a command, exit on fail
    [ -z "${1}" ] && return 1
    printf "%s \\n" "    $ sudo ${*}"
    _cmdsudo_var_output="$(printf "%s\\n" "${sudopwd}" | ${sudocmd} sh -c "eval ${*}" 2>&1)"
    _cmdsudo_var_status="${?}"
    if [ X"${_cmdsudo_var_status}" != X"0" ]; then
        printf "> %s:%s\\n" "${*}" "${_cmdsudo_var_output}"
        printf "\\n"
        exit "${_cmdsudo_var_status}"
    else
        return "${_cmdsudo_var_status}";
    fi
}

_cmdsudo_verbose() {
    [ -z "${1}" ] && return 1
    printf "%s \\n" "    $ sudo ${*}"
    printf "%s\\n" "${sudopwd}" | ${sudocmd} sh -c "eval ${*}"
}

_waitfor() { #print, execute and wait for a command to finish
    [ -z "${1}" ] && return 1
    printf "%s " "    $ ${@} ..."
    eval "${@}" >/dev/null 2>&1 &
    sleep 1s
    _animate_while "${1}"
}

_waitforsudo() { #print, execute and wait for a command to finish
    [ -z "${1}" ] && return 1
    printf "%s " "    $ sudo ${@} ..."
    printf "%s\\n" "${sudopwd}" | ${sudocmd} sh -c "eval ${*}" >/dev/null 2>&1 &
    sleep 1s
    if [ X"${1}" = X"DEBIAN_FRONTEND=noninteractive" ]; then
        _animate_while "${2}"
    else
        _animate_while "${1}"
    fi
}

_supported() { #retun 0 on a supported system, 1 otherwise
    supported="[Debian|Ubuntu]"
    case "$(_distro)" in
        ubuntu|debian) return 0 ;;
    esac
    return 1
}

_install_apt_proxy() {
    _printfs "Setting up an apt-get proxy ..."

    _apt_update 3600
    _waitforsudo apt-get install --no-install-recommends -y avahi-utils

    if _exists_apt_proxy; then
        _remotesetup_var_apt_proxy_server="$(avahi-browse -a -t -r -p | awk -F";" '/^=.*apt-cacher-ng/ {print $8}')"
        _printfs "exists an apt-get proxy at ${_remotesetup_var_apt_proxy_server}, setting up the client ..."
        _waitforsudo apt-get install --no-install-recommends -y squid-deb-proxy-client
    else
        _printfs "no apt-get proxy found, installing one locally ..."
        _waitforsudo apt-get install --no-install-recommends -y squid-deb-proxy-client apt-cacher-ng

        if [ ! -f /etc/avahi/services/apt-cacher-ng.service ]; then
            cat > /tmp/etc##avahi##services##apt-cacher-ng.service  << 'E=O=F'
<?xml version="1.0" standalone='no'?>
<!DOCTYPE service-group SYSTEM "avahi-service.dtd">
<service-group>
 <name replace-wildcards="yes">apt-cacher-ng proxy on %h</name>
 <service protocol="ipv4">
  <type>_apt_proxy._tcp</type>
  <port>3142</port>
 </service>
</service-group>
E=O=F
            _cmdsudo mkdir -p /etc/avahi/services/
            _cmdsudo mv /tmp/etc##avahi##services##apt-cacher-ng.service /etc/avahi/services/apt-cacher-ng.service
        fi

        if [ -d "${HOME}"/misc/deb-proxy/apt-cacher-ng/ ]; then
            _printfs "Exporting files ..."
            _cmdsudo rm -rf /var/cache/apt-cacher-ng
            _cmdsudo ln -s "${HOME}"/misc/deb-proxy/apt-cacher-ng/ /var/cache/apt-cacher-ng
        fi
    fi
}

_header() {
    _printfl "Minos Setup"
    printf "%b\\n" "\033[1m Updates:\033[0m  ${updates}"
    printf "\\n"

    printf "%b\\n" "\033[1m  ${cx} Core                   : \033[0m${liner}"
    printf "%b\\n" "\033[1m  ${dx} Desktop (includes Core): \033[0m${liner} d"
    #printf "%b\\n" "\033[1m  ${bx} Boot:                    \033[0m${liner} b"

    [ "$(id -u)" != "0" ] && _printfl
}

_die_sendmail() { #apt-get purge doesn't kill sendmail instances
    _diesendmail_var_pid="$(ps -aef | awk '$0 ~ "sendmail" {if ($0 !~ "awk") print $2}')"
    if [ -n "${_diesendmail_var_pid}" ]; then
        _printfs 'die sendmail, die!!'
        _cmdsudo kill "${_diesendmail_var_pid}"
    fi
}

_cleanup() {
    [ "${_cleanup_var_init}" ] && return
    _cleanup_var_init="done"
    stty echo
    [ -z "${sudopwd}" ] && return
    printf "\\n"
    _printfl "Cleanup"
    _recover_original_reps
    [ -z "${1}" ] && exit
}

_backup_original_reps() { #create a backup of /etc/apt/sources.list.d/* files
    for _backupreps_var_file in /etc/apt/sources.list.d/*.list; do
        break
    done
    [ -f "${_backupreps_var_file}" ] && _printfs "disabling temporaly non standard repos ..."
    for _backupreps_var_file in /etc/apt/sources.list.d/*.list; do
        if [ -f "${_backupreps_var_file}" ]; then
            _cmdsudo mv "${_backupreps_var_file}" "${_backupreps_var_file}".backup_rep
        fi
    done
    _tweak_apt_get
}

_recover_original_reps() { #recover files at /etc/apt/sources.list.d/*
    for _recoverreps_var_file in /etc/apt/sources.list.d/*.list.backup_rep; do
        break
    done
    [ -f "${_recoverreps_var_file}" ] && _printfs "recovering non standard repos ..."
    for _recoverreps_var_file in /etc/apt/sources.list.d/*.list.backup_rep; do
        if [ -f "${_recoverreps_var_file}" ]; then
            _cmdsudo mv "${_recoverreps_var_file}" "${_recoverreps_var_file%.backup_rep}"
        fi
    done
}

_add_repository() { #ensure rep is enabled
    [ -z "${1}" ] && return 1
    [ -z "${2}" ] && _arepository__key="" || _arepository__key="${2}"

    _arepository__baseurl="$(printf "%s" "${1}" | cut -d' ' -f2 | grep "//")"
    if [ -z "$(printf "%s" "${1}" | cut -d' ' -f3)" ] || [ -z "${_arepository__baseurl}" ]; then
        _die "Bad formated repository: ${1}"
    fi

    [ ! -d /etc/apt/sources.list.d ] && _cmdsudo mkdir /etc/apt/sources.list.d
    if [ -z "${_arepository__list}" ]; then
        _arepository__extras=/etc/apt/sources.list.d/*.list

        for _arepository__extra in ${_arepository__extras}; do
            break
        done

        if [ -e "${_arepository__extra}" ]; then
            _arepository__list="$(grep -h ^deb /etc/apt/sources.list /etc/apt/sources.list.d/*.list)"
        else
            _arepository__list="$(grep -h ^deb /etc/apt/sources.list)"
        fi
    fi

    case "${_arepository__baseurl}" in
        *archive.ubuntu.com*)
            _arepository__regex="$(printf "%s" "${1}" | cut -d' ' -f3-4)"
            _arepository__name="$(printf "%s" "${1}" | cut -d' ' -f3-4 | tr ' ' '-')"
            ;;
        *)
            _arepository__regex="${_arepository__baseurl}"
            if [ -n "$(printf "%s" "${_arepository__baseurl}" | cut -d'/' -f5)" ]; then
                _arepository__name="$(printf "%s" "${_arepository__baseurl}" \
                                     | cut -d'/' -f4-5 | tr '/' '-')"
            else
                _arepository__name="$(printf "%s" "${_arepository__baseurl}" \
                                     | cut -d'/' -f3-4 | tr '/' '-')"
            fi
            if [ -z "$(printf "%s" "${1}" | cut -d' ' -f4)" ]; then
                _arepository__name="$(printf "%s" "${_arepository__baseurl}" \
                    | cut -d'/' -f 3 | awk -F. '{print $(NF-1)}')"-"${_arepository__name}"
            fi
            ;;
    esac

    if ! printf "%s" "${_arepository__list}" | grep "${_arepository__regex}" >/dev/null; then
        printf "%s\\n" "${1}" > /tmp/"${_arepository__name}".list
        _cmdsudo mv /tmp/"${_arepository__name}".list /etc/apt/sources.list.d/
        if [ -n "${_arepository__key}" ]; then
            if printf "%s" "${_arepository__key}" | grep "http" >/dev/null; then
                _fetch_file ${_arepository__key} /tmp/keyfile.asc
                _waitforsudo apt-key add /tmp/keyfile.asc
                _cmd rm -rf /tmp/keyfile.asc
            else
                _waitforsudo apt-get install --no-install-recommends -y gnupg
                _waitforsudo apt-key adv --keyserver keyserver.ubuntu.com \
                --recv-keys "${_arepository__key}"
            fi
        fi
    fi
}

_virt_what() { #check for virtualization systems, returns technology used
    if [ -d /proc/vz ] && [ ! -d /proc/bc ]; then
        printf "openvz"
    elif grep 'UML' /proc/cpuinfo >/dev/null 2>&1; then
        printf "uml"
    elif [ -f /proc/xen/capabilities ]; then
        printf "xen"
    elif grep 'QEMU' /proc/cpuinfo >/dev/null 2>&1; then
        printf "qemu"
    elif grep 'Hypervisor detected' /var/log/dmesg >/dev/null 2>&1; then
        awk '/Hypervisor detected/ {print tolower($NF); exit; }' /var/log/dmesg
    fi
    return 1
}

_tweak_apt_get() {
    _printfl "Tweaking apt-get"
    printf "%s\\n" '    $ printf "%s\n" "Dir::Ignore-Files-Silently:: "(.save|.distUpgrade|.backup_rep)$";" > /tmp/minos-apt-99ignoresave'
    printf "%s"    'Dir::Ignore-Files-Silently:: "(.save|.distUpgrade|.backup_rep)$";' > /tmp/minos-apt-99ignoresave
    _cmdsudo       mv /tmp/minos-apt-99ignoresave /etc/apt/apt.conf.d/99ignoresave

    #we're about to install many packages, speed up the process for future runs
    _install_apt_proxy
}

_add_minos_repository() {
    _printfl "Adding repositories"
    _add_repository "deb http://ppa.launchpad.net/minos-archive/main/ubuntu ${1} main" "4A06406469B4B061"
    _add_repository "deb http://archive.ubuntu.com/ubuntu/ ${1} multiverse"
    _add_repository "deb http://archive.ubuntu.com/ubuntu/ ${1}-updates multiverse"
    _apt_update 0
}

################################################################################
# Deployment functions #########################################################
################################################################################

_core() {
    if [ -n "$(_get_release)" ]; then
        _backup_original_reps
        _add_minos_repository "$(_get_release)"
    else
        _die "Couldn't find valid release"
    fi

    _printfs "Installing packages ..."
    #_waitforsudo apt-get install --no-install-recommends -y minos-core
    _cmdsudo_verbose apt-get install --no-install-recommends -y --force-yes \
        minos-core || _die "Installation failed"
    _recover_original_reps

    _printfs "Removing leftovers  ..."
    _waitforsudo apt-get purge -y squid-deb-proxy-client apt-cacher-ng
    _waitforsudo apt-get autoremove

    _printfl "DONE"
    printf "\\n%s\\n" "Reload your session or relogin to get started, have fun! n@n/"
    printf "%s\\n"    "    $ source ~/.bashrc"
}

_desktop() {
    if [ -n "$(_get_release)" ]; then
        _backup_original_reps
        _add_minos_repository "$(_get_release)"
    else
        _die "Couldn't find valid release"
    fi

    _printfs "Installing packages ..."
    #_waitforsudo DEBIAN_FRONTEND=noninteractive apt-get install --no-install-recommends -y minos-desktop
    _cmdsudo_verbose \
        DEBIAN_FRONTEND=noninteractive apt-get install --no-install-recommends \
        -y --force-yes minos-desktop || _die "Installation failed"
    #[ -d "${HOME}"/.gvfs ] && fusermount -u "${HOME}"/.gvfs
    _recover_original_reps

    _printfl "DONE"
    printf   "\\n%s\\n" "Restart your computer to get started, have fun!, n@n/"
}

################################################################################
# Main #########################################################################
################################################################################

_header
if _supported; then
    #the _hook function execute $HOME/s/[LETTER][NUMBER] scripts
    #eg: $HOME/s/A01action, $HOME/s/B01installextra, $HOME/s/Z01finish
    _hooks A #these hooks wont have super powers
    _get_root_passwd
    _hooks B #super powers are available through the "_cmdsudo" function
             #e.g, _cmdsudo mkdir /root/forbidden_directory
    case "${mode}" in
           core)  _core    ;;
        desktop)  _desktop ;;
    esac
    _hooks C; : #finish script with 0, independly of latest hooks result
else
    printf "%s %s\\n" "FAILED: Non supported distribution system detected," \
            "run this script on ${supported} systems only"
fi

# vim: set ts=8 sw=4 tw=0 ft=sh :
